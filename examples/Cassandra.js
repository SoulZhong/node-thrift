//
// Autogenerated by Thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;
var ttypes = require('./cassandra_types.js');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args){
this.keyspace = null
this.auth_request = null
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.auth_request)
this.auth_request = args.auth_request
}}
Cassandra_login_args.prototype = {}
Cassandra_login_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.auth_request = new ttypes.AuthenticationRequest()
this.auth_request.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_login_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_login_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.auth_request) {
output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 2)
this.auth_request.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_login_result = function(args){
this.authnx = null
this.authzx = null
if( args != null ){if (null != args.authnx)
this.authnx = args.authnx
if (null != args.authzx)
this.authzx = args.authzx
}}
Cassandra_login_result.prototype = {}
Cassandra_login_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRUCT) {
this.authnx = new ttypes.AuthenticationException()
this.authnx.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.authzx = new ttypes.AuthorizationException()
this.authzx.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_login_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_login_result')
if (null != this.authnx) {
output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1)
this.authnx.write(output)
output.writeFieldEnd()
}
if (null != this.authzx) {
output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2)
this.authzx.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_args = function(args){
this.keyspace = null
this.key = null
this.column_path = null
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.key)
this.key = args.key
if (null != args.column_path)
this.column_path = args.column_path
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_get_args.prototype = {}
Cassandra_get_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_path = new ttypes.ColumnPath()
this.column_path.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.key) {
output.writeFieldBegin('key', Thrift.Type.STRING, 2)
output.writeString(this.key)
output.writeFieldEnd()
}
if (null != this.column_path) {
output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 3)
this.column_path.write(output)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_result = function(args){
this.success = null
this.ire = null
this.nfe = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.nfe)
this.nfe = args.nfe
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_get_result.prototype = {}
Cassandra_get_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.STRUCT) {
this.success = new ttypes.ColumnOrSuperColumn()
this.success.read(input)
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.nfe = new ttypes.NotFoundException()
this.nfe.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
this.success.write(output)
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.nfe) {
output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2)
this.nfe.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 4)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_slice_args = function(args){
this.keyspace = null
this.key = null
this.column_parent = null
this.predicate = null
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.key)
this.key = args.key
if (null != args.column_parent)
this.column_parent = args.column_parent
if (null != args.predicate)
this.predicate = args.predicate
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_get_slice_args.prototype = {}
Cassandra_get_slice_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_parent = new ttypes.ColumnParent()
this.column_parent.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.STRUCT) {
this.predicate = new ttypes.SlicePredicate()
this.predicate.read(input)
} else {
  input.skip(ftype)
}
break
case 5:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_slice_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_slice_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.key) {
output.writeFieldBegin('key', Thrift.Type.STRING, 2)
output.writeString(this.key)
output.writeFieldEnd()
}
if (null != this.column_parent) {
output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 3)
this.column_parent.write(output)
output.writeFieldEnd()
}
if (null != this.predicate) {
output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 4)
this.predicate.write(output)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 5)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_slice_result = function(args){
this.success = null
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_get_slice_result.prototype = {}
Cassandra_get_slice_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.LIST) {
{
var _size37 = 0
var rtmp3
this.success = []
var _etype40 = 0
rtmp3 = input.readListBegin()
_etype40 = rtmp3.etype
_size37 = rtmp3.size
for (var _i41 = 0; _i41 < _size37; ++_i41)
{
var elem42 = null
elem42 = new ttypes.ColumnOrSuperColumn()
elem42.read(input)
this.success.push(elem42)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_slice_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_slice_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.LIST, 0)
{
output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
{
for(var iter43 in this.success)
{
iter43=this.success[iter43]
iter43.write(output)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_multiget_args = function(args){
this.keyspace = null
this.keys = null
this.column_path = null
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.keys)
this.keys = args.keys
if (null != args.column_path)
this.column_path = args.column_path
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_multiget_args.prototype = {}
Cassandra_multiget_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.LIST) {
{
var _size44 = 0
var rtmp3
this.keys = []
var _etype47 = 0
rtmp3 = input.readListBegin()
_etype47 = rtmp3.etype
_size44 = rtmp3.size
for (var _i48 = 0; _i48 < _size44; ++_i48)
{
var elem49 = null
var rtmp = input.readString()
elem49 = rtmp.value
this.keys.push(elem49)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_path = new ttypes.ColumnPath()
this.column_path.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_multiget_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_multiget_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.keys) {
output.writeFieldBegin('keys', Thrift.Type.LIST, 2)
{
output.writeListBegin(Thrift.Type.STRING, this.keys.length)
{
for(var iter50 in this.keys)
{
iter50=this.keys[iter50]
output.writeString(iter50)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
if (null != this.column_path) {
output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 3)
this.column_path.write(output)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_multiget_result = function(args){
this.success = null
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_multiget_result.prototype = {}
Cassandra_multiget_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.MAP) {
{
var _size51 = 0
var rtmp3
this.success = {}
var _ktype52 = 0
var _vtype53 = 0
rtmp3 = input.readMapBegin()
_ktype52= rtmp3.ktype
_vtype53= rtmp3.vtype
_size51= rtmp3.size
for (var _i55 = 0; _i55 < _size51; ++_i55)
{
key56 = null
val57 = null
var rtmp = input.readString()
key56 = rtmp.value
val57 = new ttypes.ColumnOrSuperColumn()
val57.read(input)
this.success[key56] = val57
}
input.readMapEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_multiget_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_multiget_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.MAP, 0)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, this.success.length)
{
for(var kiter58 in this.success){
var viter59 = this.success[kiter58]
output.writeString(kiter58)
viter59.write(output)
}
}
output.writeMapEnd()
}
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_multiget_slice_args = function(args){
this.keyspace = null
this.keys = null
this.column_parent = null
this.predicate = null
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.keys)
this.keys = args.keys
if (null != args.column_parent)
this.column_parent = args.column_parent
if (null != args.predicate)
this.predicate = args.predicate
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_multiget_slice_args.prototype = {}
Cassandra_multiget_slice_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.LIST) {
{
var _size60 = 0
var rtmp3
this.keys = []
var _etype63 = 0
rtmp3 = input.readListBegin()
_etype63 = rtmp3.etype
_size60 = rtmp3.size
for (var _i64 = 0; _i64 < _size60; ++_i64)
{
var elem65 = null
var rtmp = input.readString()
elem65 = rtmp.value
this.keys.push(elem65)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_parent = new ttypes.ColumnParent()
this.column_parent.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.STRUCT) {
this.predicate = new ttypes.SlicePredicate()
this.predicate.read(input)
} else {
  input.skip(ftype)
}
break
case 5:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_multiget_slice_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_multiget_slice_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.keys) {
output.writeFieldBegin('keys', Thrift.Type.LIST, 2)
{
output.writeListBegin(Thrift.Type.STRING, this.keys.length)
{
for(var iter66 in this.keys)
{
iter66=this.keys[iter66]
output.writeString(iter66)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
if (null != this.column_parent) {
output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 3)
this.column_parent.write(output)
output.writeFieldEnd()
}
if (null != this.predicate) {
output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 4)
this.predicate.write(output)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 5)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_multiget_slice_result = function(args){
this.success = null
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_multiget_slice_result.prototype = {}
Cassandra_multiget_slice_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.MAP) {
{
var _size67 = 0
var rtmp3
this.success = {}
var _ktype68 = 0
var _vtype69 = 0
rtmp3 = input.readMapBegin()
_ktype68= rtmp3.ktype
_vtype69= rtmp3.vtype
_size67= rtmp3.size
for (var _i71 = 0; _i71 < _size67; ++_i71)
{
key72 = null
val73 = null
var rtmp = input.readString()
key72 = rtmp.value
{
var _size74 = 0
var rtmp3
val73 = []
var _etype77 = 0
rtmp3 = input.readListBegin()
_etype77 = rtmp3.etype
_size74 = rtmp3.size
for (var _i78 = 0; _i78 < _size74; ++_i78)
{
var elem79 = null
elem79 = new ttypes.ColumnOrSuperColumn()
elem79.read(input)
val73.push(elem79)
}
input.readListEnd()
}
this.success[key72] = val73
}
input.readMapEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_multiget_slice_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_multiget_slice_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.MAP, 0)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, this.success.length)
{
for(var kiter80 in this.success){
var viter81 = this.success[kiter80]
output.writeString(kiter80)
{
output.writeListBegin(Thrift.Type.STRUCT, viter81.length)
{
for(var iter82 in viter81)
{
iter82=viter81[iter82]
iter82.write(output)
}
}
output.writeListEnd()
}
}
}
output.writeMapEnd()
}
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_count_args = function(args){
this.keyspace = null
this.key = null
this.column_parent = null
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.key)
this.key = args.key
if (null != args.column_parent)
this.column_parent = args.column_parent
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_get_count_args.prototype = {}
Cassandra_get_count_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_parent = new ttypes.ColumnParent()
this.column_parent.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_count_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_count_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.key) {
output.writeFieldBegin('key', Thrift.Type.STRING, 2)
output.writeString(this.key)
output.writeFieldEnd()
}
if (null != this.column_parent) {
output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 3)
this.column_parent.write(output)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_count_result = function(args){
this.success = null
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_get_count_result.prototype = {}
Cassandra_get_count_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.success = rtmp.value
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_count_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_count_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.I32, 0)
output.writeI32(this.success)
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_range_slice_args = function(args){
this.keyspace = null
this.column_parent = null
this.predicate = null
this.start_key = ''
this.finish_key = ''
this.row_count = 100
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.column_parent)
this.column_parent = args.column_parent
if (null != args.predicate)
this.predicate = args.predicate
if (null != args.start_key)
this.start_key = args.start_key
if (null != args.finish_key)
this.finish_key = args.finish_key
if (null != args.row_count)
this.row_count = args.row_count
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_get_range_slice_args.prototype = {}
Cassandra_get_range_slice_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.column_parent = new ttypes.ColumnParent()
this.column_parent.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.predicate = new ttypes.SlicePredicate()
this.predicate.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.start_key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 5:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.finish_key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 6:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.row_count = rtmp.value
} else {
  input.skip(ftype)
}
break
case 7:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_range_slice_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_range_slice_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.column_parent) {
output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
this.column_parent.write(output)
output.writeFieldEnd()
}
if (null != this.predicate) {
output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
this.predicate.write(output)
output.writeFieldEnd()
}
if (null != this.start_key) {
output.writeFieldBegin('start_key', Thrift.Type.STRING, 4)
output.writeString(this.start_key)
output.writeFieldEnd()
}
if (null != this.finish_key) {
output.writeFieldBegin('finish_key', Thrift.Type.STRING, 5)
output.writeString(this.finish_key)
output.writeFieldEnd()
}
if (null != this.row_count) {
output.writeFieldBegin('row_count', Thrift.Type.I32, 6)
output.writeI32(this.row_count)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 7)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_range_slice_result = function(args){
this.success = null
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_get_range_slice_result.prototype = {}
Cassandra_get_range_slice_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.LIST) {
{
var _size83 = 0
var rtmp3
this.success = []
var _etype86 = 0
rtmp3 = input.readListBegin()
_etype86 = rtmp3.etype
_size83 = rtmp3.size
for (var _i87 = 0; _i87 < _size83; ++_i87)
{
var elem88 = null
elem88 = new ttypes.KeySlice()
elem88.read(input)
this.success.push(elem88)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_range_slice_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_range_slice_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.LIST, 0)
{
output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
{
for(var iter89 in this.success)
{
iter89=this.success[iter89]
iter89.write(output)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_range_slices_args = function(args){
this.keyspace = null
this.column_parent = null
this.predicate = null
this.range = null
this.consistency_level = 1
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.column_parent)
this.column_parent = args.column_parent
if (null != args.predicate)
this.predicate = args.predicate
if (null != args.range)
this.range = args.range
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_get_range_slices_args.prototype = {}
Cassandra_get_range_slices_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.column_parent = new ttypes.ColumnParent()
this.column_parent.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.predicate = new ttypes.SlicePredicate()
this.predicate.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.STRUCT) {
this.range = new ttypes.KeyRange()
this.range.read(input)
} else {
  input.skip(ftype)
}
break
case 5:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_range_slices_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_range_slices_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.column_parent) {
output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
this.column_parent.write(output)
output.writeFieldEnd()
}
if (null != this.predicate) {
output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
this.predicate.write(output)
output.writeFieldEnd()
}
if (null != this.range) {
output.writeFieldBegin('range', Thrift.Type.STRUCT, 4)
this.range.write(output)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 5)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_range_slices_result = function(args){
this.success = null
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_get_range_slices_result.prototype = {}
Cassandra_get_range_slices_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.LIST) {
{
var _size90 = 0
var rtmp3
this.success = []
var _etype93 = 0
rtmp3 = input.readListBegin()
_etype93 = rtmp3.etype
_size90 = rtmp3.size
for (var _i94 = 0; _i94 < _size90; ++_i94)
{
var elem95 = null
elem95 = new ttypes.KeySlice()
elem95.read(input)
this.success.push(elem95)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_range_slices_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_range_slices_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.LIST, 0)
{
output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
{
for(var iter96 in this.success)
{
iter96=this.success[iter96]
iter96.write(output)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_insert_args = function(args){
this.keyspace = null
this.key = null
this.column_path = null
this.value = null
this.timestamp = null
this.consistency_level = 0
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.key)
this.key = args.key
if (null != args.column_path)
this.column_path = args.column_path
if (null != args.value)
this.value = args.value
if (null != args.timestamp)
this.timestamp = args.timestamp
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_insert_args.prototype = {}
Cassandra_insert_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_path = new ttypes.ColumnPath()
this.column_path.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.value = rtmp.value
} else {
  input.skip(ftype)
}
break
case 5:if (ftype == Thrift.Type.I64) {
var rtmp = input.readI64()
this.timestamp = rtmp.value
} else {
  input.skip(ftype)
}
break
case 6:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_insert_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_insert_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.key) {
output.writeFieldBegin('key', Thrift.Type.STRING, 2)
output.writeString(this.key)
output.writeFieldEnd()
}
if (null != this.column_path) {
output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 3)
this.column_path.write(output)
output.writeFieldEnd()
}
if (null != this.value) {
output.writeFieldBegin('value', Thrift.Type.STRING, 4)
output.writeString(this.value)
output.writeFieldEnd()
}
if (null != this.timestamp) {
output.writeFieldBegin('timestamp', Thrift.Type.I64, 5)
output.writeI64(this.timestamp)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 6)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_insert_result = function(args){
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_insert_result.prototype = {}
Cassandra_insert_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_insert_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_insert_result')
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_batch_insert_args = function(args){
this.keyspace = null
this.key = null
this.cfmap = null
this.consistency_level = 0
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.key)
this.key = args.key
if (null != args.cfmap)
this.cfmap = args.cfmap
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_batch_insert_args.prototype = {}
Cassandra_batch_insert_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.MAP) {
{
var _size97 = 0
var rtmp3
this.cfmap = {}
var _ktype98 = 0
var _vtype99 = 0
rtmp3 = input.readMapBegin()
_ktype98= rtmp3.ktype
_vtype99= rtmp3.vtype
_size97= rtmp3.size
for (var _i101 = 0; _i101 < _size97; ++_i101)
{
key102 = null
val103 = null
var rtmp = input.readString()
key102 = rtmp.value
{
var _size104 = 0
var rtmp3
val103 = []
var _etype107 = 0
rtmp3 = input.readListBegin()
_etype107 = rtmp3.etype
_size104 = rtmp3.size
for (var _i108 = 0; _i108 < _size104; ++_i108)
{
var elem109 = null
elem109 = new ttypes.ColumnOrSuperColumn()
elem109.read(input)
val103.push(elem109)
}
input.readListEnd()
}
this.cfmap[key102] = val103
}
input.readMapEnd()
}
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_batch_insert_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_batch_insert_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.key) {
output.writeFieldBegin('key', Thrift.Type.STRING, 2)
output.writeString(this.key)
output.writeFieldEnd()
}
if (null != this.cfmap) {
output.writeFieldBegin('cfmap', Thrift.Type.MAP, 3)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, this.cfmap.length)
{
for(var kiter110 in this.cfmap){
var viter111 = this.cfmap[kiter110]
output.writeString(kiter110)
{
output.writeListBegin(Thrift.Type.STRUCT, viter111.length)
{
for(var iter112 in viter111)
{
iter112=viter111[iter112]
iter112.write(output)
}
}
output.writeListEnd()
}
}
}
output.writeMapEnd()
}
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_batch_insert_result = function(args){
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_batch_insert_result.prototype = {}
Cassandra_batch_insert_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_batch_insert_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_batch_insert_result')
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_remove_args = function(args){
this.keyspace = null
this.key = null
this.column_path = null
this.timestamp = null
this.consistency_level = 0
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.key)
this.key = args.key
if (null != args.column_path)
this.column_path = args.column_path
if (null != args.timestamp)
this.timestamp = args.timestamp
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_remove_args.prototype = {}
Cassandra_remove_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.key = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.column_path = new ttypes.ColumnPath()
this.column_path.read(input)
} else {
  input.skip(ftype)
}
break
case 4:if (ftype == Thrift.Type.I64) {
var rtmp = input.readI64()
this.timestamp = rtmp.value
} else {
  input.skip(ftype)
}
break
case 5:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_remove_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_remove_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.key) {
output.writeFieldBegin('key', Thrift.Type.STRING, 2)
output.writeString(this.key)
output.writeFieldEnd()
}
if (null != this.column_path) {
output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 3)
this.column_path.write(output)
output.writeFieldEnd()
}
if (null != this.timestamp) {
output.writeFieldBegin('timestamp', Thrift.Type.I64, 4)
output.writeI64(this.timestamp)
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 5)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_remove_result = function(args){
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_remove_result.prototype = {}
Cassandra_remove_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_remove_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_remove_result')
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_batch_mutate_args = function(args){
this.keyspace = null
this.mutation_map = null
this.consistency_level = 0
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
if (null != args.mutation_map)
this.mutation_map = args.mutation_map
if (null != args.consistency_level)
this.consistency_level = args.consistency_level
}}
Cassandra_batch_mutate_args.prototype = {}
Cassandra_batch_mutate_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.MAP) {
{
var _size113 = 0
var rtmp3
this.mutation_map = {}
var _ktype114 = 0
var _vtype115 = 0
rtmp3 = input.readMapBegin()
_ktype114= rtmp3.ktype
_vtype115= rtmp3.vtype
_size113= rtmp3.size
for (var _i117 = 0; _i117 < _size113; ++_i117)
{
key118 = null
val119 = null
var rtmp = input.readString()
key118 = rtmp.value
{
var _size120 = 0
var rtmp3
val119 = {}
var _ktype121 = 0
var _vtype122 = 0
rtmp3 = input.readMapBegin()
_ktype121= rtmp3.ktype
_vtype122= rtmp3.vtype
_size120= rtmp3.size
for (var _i124 = 0; _i124 < _size120; ++_i124)
{
key125 = null
val126 = null
var rtmp = input.readString()
key125 = rtmp.value
{
var _size127 = 0
var rtmp3
val126 = []
var _etype130 = 0
rtmp3 = input.readListBegin()
_etype130 = rtmp3.etype
_size127 = rtmp3.size
for (var _i131 = 0; _i131 < _size127; ++_i131)
{
var elem132 = null
elem132 = new ttypes.Mutation()
elem132.read(input)
val126.push(elem132)
}
input.readListEnd()
}
val119[key125] = val126
}
input.readMapEnd()
}
this.mutation_map[key118] = val119
}
input.readMapEnd()
}
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.consistency_level = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_batch_mutate_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_batch_mutate_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
if (null != this.mutation_map) {
output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 2)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, this.mutation_map.length)
{
for(var kiter133 in this.mutation_map){
var viter134 = this.mutation_map[kiter133]
output.writeString(kiter133)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, viter134.length)
{
for(var kiter135 in viter134){
var viter136 = viter134[kiter135]
output.writeString(kiter135)
{
output.writeListBegin(Thrift.Type.STRUCT, viter136.length)
{
for(var iter137 in viter136)
{
iter137=viter136[iter137]
iter137.write(output)
}
}
output.writeListEnd()
}
}
}
output.writeMapEnd()
}
}
}
output.writeMapEnd()
}
output.writeFieldEnd()
}
if (null != this.consistency_level) {
output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3)
output.writeI32(this.consistency_level)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_batch_mutate_result = function(args){
this.ire = null
this.ue = null
this.te = null
if( args != null ){if (null != args.ire)
this.ire = args.ire
if (null != args.ue)
this.ue = args.ue
if (null != args.te)
this.te = args.te
}}
Cassandra_batch_mutate_result.prototype = {}
Cassandra_batch_mutate_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRUCT) {
this.ire = new ttypes.InvalidRequestException()
this.ire.read(input)
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRUCT) {
this.ue = new ttypes.UnavailableException()
this.ue.read(input)
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.STRUCT) {
this.te = new ttypes.TimedOutException()
this.te.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_batch_mutate_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_batch_mutate_result')
if (null != this.ire) {
output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
this.ire.write(output)
output.writeFieldEnd()
}
if (null != this.ue) {
output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
this.ue.write(output)
output.writeFieldEnd()
}
if (null != this.te) {
output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
this.te.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_string_property_args = function(args){
this.property = null
if( args != null ){if (null != args.property)
this.property = args.property
}}
Cassandra_get_string_property_args.prototype = {}
Cassandra_get_string_property_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.property = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_string_property_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_string_property_args')
if (null != this.property) {
output.writeFieldBegin('property', Thrift.Type.STRING, 1)
output.writeString(this.property)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_string_property_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_get_string_property_result.prototype = {}
Cassandra_get_string_property_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.success = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_string_property_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_string_property_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.STRING, 0)
output.writeString(this.success)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_string_list_property_args = function(args){
this.property = null
if( args != null ){if (null != args.property)
this.property = args.property
}}
Cassandra_get_string_list_property_args.prototype = {}
Cassandra_get_string_list_property_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.property = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_string_list_property_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_string_list_property_args')
if (null != this.property) {
output.writeFieldBegin('property', Thrift.Type.STRING, 1)
output.writeString(this.property)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_string_list_property_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_get_string_list_property_result.prototype = {}
Cassandra_get_string_list_property_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.LIST) {
{
var _size138 = 0
var rtmp3
this.success = []
var _etype141 = 0
rtmp3 = input.readListBegin()
_etype141 = rtmp3.etype
_size138 = rtmp3.size
for (var _i142 = 0; _i142 < _size138; ++_i142)
{
var elem143 = null
var rtmp = input.readString()
elem143 = rtmp.value
this.success.push(elem143)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_string_list_property_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_string_list_property_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.LIST, 0)
{
output.writeListBegin(Thrift.Type.STRING, this.success.length)
{
for(var iter144 in this.success)
{
iter144=this.success[iter144]
output.writeString(iter144)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_keyspaces_args = function(args){
}
Cassandra_describe_keyspaces_args.prototype = {}
Cassandra_describe_keyspaces_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_keyspaces_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_keyspaces_args')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_keyspaces_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_describe_keyspaces_result.prototype = {}
Cassandra_describe_keyspaces_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.SET) {
{
var _size145 = 0
var rtmp3
this.success = []
var _etype148 = 0
rtmp3 = input.readSetBegin()
_etype148= rtmp3.etype
_size145 = rtmp3.size
for (var _i149 = 0; _i149 < _size145; ++_i149)
{
var elem150 = null
var rtmp = input.readString()
elem150 = rtmp.value
this.success.push(elem150)
}
input.readSetEnd()
}
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_keyspaces_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_keyspaces_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.SET, 0)
{
output.writeSetBegin(Thrift.Type.STRING, this.success.length)
{
for(var iter151 in this.success)
{
iter151=this.success[iter151]
output.writeString(iter151)
}
}
output.writeSetEnd()
}
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_cluster_name_args = function(args){
}
Cassandra_describe_cluster_name_args.prototype = {}
Cassandra_describe_cluster_name_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_cluster_name_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_cluster_name_args')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_cluster_name_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_describe_cluster_name_result.prototype = {}
Cassandra_describe_cluster_name_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.success = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_cluster_name_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_cluster_name_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.STRING, 0)
output.writeString(this.success)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_version_args = function(args){
}
Cassandra_describe_version_args.prototype = {}
Cassandra_describe_version_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_version_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_version_args')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_version_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_describe_version_result.prototype = {}
Cassandra_describe_version_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.success = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_version_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_version_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.STRING, 0)
output.writeString(this.success)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_ring_args = function(args){
this.keyspace = null
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
}}
Cassandra_describe_ring_args.prototype = {}
Cassandra_describe_ring_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_ring_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_ring_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_ring_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_describe_ring_result.prototype = {}
Cassandra_describe_ring_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.LIST) {
{
var _size152 = 0
var rtmp3
this.success = []
var _etype155 = 0
rtmp3 = input.readListBegin()
_etype155 = rtmp3.etype
_size152 = rtmp3.size
for (var _i156 = 0; _i156 < _size152; ++_i156)
{
var elem157 = null
elem157 = new ttypes.TokenRange()
elem157.read(input)
this.success.push(elem157)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_ring_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_ring_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.LIST, 0)
{
output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
{
for(var iter158 in this.success)
{
iter158=this.success[iter158]
iter158.write(output)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_keyspace_args = function(args){
this.keyspace = null
if( args != null ){if (null != args.keyspace)
this.keyspace = args.keyspace
}}
Cassandra_describe_keyspace_args.prototype = {}
Cassandra_describe_keyspace_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.keyspace = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_keyspace_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_keyspace_args')
if (null != this.keyspace) {
output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
output.writeString(this.keyspace)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_keyspace_result = function(args){
this.success = null
this.nfe = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.nfe)
this.nfe = args.nfe
}}
Cassandra_describe_keyspace_result.prototype = {}
Cassandra_describe_keyspace_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.MAP) {
{
var _size159 = 0
var rtmp3
this.success = {}
var _ktype160 = 0
var _vtype161 = 0
rtmp3 = input.readMapBegin()
_ktype160= rtmp3.ktype
_vtype161= rtmp3.vtype
_size159= rtmp3.size
for (var _i163 = 0; _i163 < _size159; ++_i163)
{
key164 = null
val165 = null
var rtmp = input.readString()
key164 = rtmp.value
{
var _size166 = 0
var rtmp3
val165 = {}
var _ktype167 = 0
var _vtype168 = 0
rtmp3 = input.readMapBegin()
_ktype167= rtmp3.ktype
_vtype168= rtmp3.vtype
_size166= rtmp3.size
for (var _i170 = 0; _i170 < _size166; ++_i170)
{
key171 = null
val172 = null
var rtmp = input.readString()
key171 = rtmp.value
var rtmp = input.readString()
val172 = rtmp.value
val165[key171] = val172
}
input.readMapEnd()
}
this.success[key164] = val165
}
input.readMapEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.nfe = new ttypes.NotFoundException()
this.nfe.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_keyspace_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_keyspace_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.MAP, 0)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, this.success.length)
{
for(var kiter173 in this.success){
var viter174 = this.success[kiter173]
output.writeString(kiter173)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, viter174.length)
{
for(var kiter175 in viter174){
var viter176 = viter174[kiter175]
output.writeString(kiter175)
output.writeString(viter176)
}
}
output.writeMapEnd()
}
}
}
output.writeMapEnd()
}
output.writeFieldEnd()
}
if (null != this.nfe) {
output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1)
this.nfe.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_take_snapshot_args = function(args){
this.table_name = null
this.snapshot_name = null
if( args != null ){if (null != args.table_name)
this.table_name = args.table_name
if (null != args.snapshot_name)
this.snapshot_name = args.snapshot_name
}}
Cassandra_take_snapshot_args.prototype = {}
Cassandra_take_snapshot_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.table_name = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.snapshot_name = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_take_snapshot_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_take_snapshot_args')
if (null != this.table_name) {
output.writeFieldBegin('table_name', Thrift.Type.STRING, 1)
output.writeString(this.table_name)
output.writeFieldEnd()
}
if (null != this.snapshot_name) {
output.writeFieldBegin('snapshot_name', Thrift.Type.STRING, 2)
output.writeString(this.snapshot_name)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_take_snapshot_result = function(args){
}
Cassandra_take_snapshot_result.prototype = {}
Cassandra_take_snapshot_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_take_snapshot_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_take_snapshot_result')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_force_table_clean_args = function(args){
}
Cassandra_force_table_clean_args.prototype = {}
Cassandra_force_table_clean_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_force_table_clean_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_force_table_clean_args')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_force_table_clean_result = function(args){
}
Cassandra_force_table_clean_result.prototype = {}
Cassandra_force_table_clean_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_force_table_clean_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_force_table_clean_result')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_force_table_compaction_args = function(args){
}
Cassandra_force_table_compaction_args.prototype = {}
Cassandra_force_table_compaction_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_force_table_compaction_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_force_table_compaction_args')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_force_table_compaction_result = function(args){
}
Cassandra_force_table_compaction_result.prototype = {}
Cassandra_force_table_compaction_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_force_table_compaction_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_force_table_compaction_result')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_force_table_flush_args = function(args){
this.table_name = null
if( args != null ){if (null != args.table_name)
this.table_name = args.table_name
}}
Cassandra_force_table_flush_args.prototype = {}
Cassandra_force_table_flush_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.table_name = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_force_table_flush_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_force_table_flush_args')
if (null != this.table_name) {
output.writeFieldBegin('table_name', Thrift.Type.STRING, 1)
output.writeString(this.table_name)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_force_table_flush_result = function(args){
}
Cassandra_force_table_flush_result.prototype = {}
Cassandra_force_table_flush_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_force_table_flush_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_force_table_flush_result')
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_table_stats_args = function(args){
this.table_name = null
if( args != null ){if (null != args.table_name)
this.table_name = args.table_name
}}
Cassandra_get_table_stats_args.prototype = {}
Cassandra_get_table_stats_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.table_name = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_table_stats_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_table_stats_args')
if (null != this.table_name) {
output.writeFieldBegin('table_name', Thrift.Type.STRING, 1)
output.writeString(this.table_name)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_get_table_stats_result = function(args){
this.success = null
this.nfe = null
if( args != null ){if (null != args.success)
this.success = args.success
if (null != args.nfe)
this.nfe = args.nfe
}}
Cassandra_get_table_stats_result.prototype = {}
Cassandra_get_table_stats_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.MAP) {
{
var _size177 = 0
var rtmp3
this.success = {}
var _ktype178 = 0
var _vtype179 = 0
rtmp3 = input.readMapBegin()
_ktype178= rtmp3.ktype
_vtype179= rtmp3.vtype
_size177= rtmp3.size
for (var _i181 = 0; _i181 < _size177; ++_i181)
{
key182 = null
val183 = null
var rtmp = input.readString()
key182 = rtmp.value
{
var _size184 = 0
var rtmp3
val183 = {}
var _ktype185 = 0
var _vtype186 = 0
rtmp3 = input.readMapBegin()
_ktype185= rtmp3.ktype
_vtype186= rtmp3.vtype
_size184= rtmp3.size
for (var _i188 = 0; _i188 < _size184; ++_i188)
{
key189 = null
val190 = null
var rtmp = input.readString()
key189 = rtmp.value
var rtmp = input.readString()
val190 = rtmp.value
val183[key189] = val190
}
input.readMapEnd()
}
this.success[key182] = val183
}
input.readMapEnd()
}
} else {
  input.skip(ftype)
}
break
case 1:if (ftype == Thrift.Type.STRUCT) {
this.nfe = new ttypes.NotFoundException()
this.nfe.read(input)
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_get_table_stats_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_get_table_stats_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.MAP, 0)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, this.success.length)
{
for(var kiter191 in this.success){
var viter192 = this.success[kiter191]
output.writeString(kiter191)
{
output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, viter192.length)
{
for(var kiter193 in viter192){
var viter194 = viter192[kiter193]
output.writeString(kiter193)
output.writeString(viter194)
}
}
output.writeMapEnd()
}
}
}
output.writeMapEnd()
}
output.writeFieldEnd()
}
if (null != this.nfe) {
output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1)
this.nfe.write(output)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_splits_args = function(args){
this.start_token = null
this.end_token = null
this.keys_per_split = null
if( args != null ){if (null != args.start_token)
this.start_token = args.start_token
if (null != args.end_token)
this.end_token = args.end_token
if (null != args.keys_per_split)
this.keys_per_split = args.keys_per_split
}}
Cassandra_describe_splits_args.prototype = {}
Cassandra_describe_splits_args.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 1:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.start_token = rtmp.value
} else {
  input.skip(ftype)
}
break
case 2:if (ftype == Thrift.Type.STRING) {
var rtmp = input.readString()
this.end_token = rtmp.value
} else {
  input.skip(ftype)
}
break
case 3:if (ftype == Thrift.Type.I32) {
var rtmp = input.readI32()
this.keys_per_split = rtmp.value
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_splits_args.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_splits_args')
if (null != this.start_token) {
output.writeFieldBegin('start_token', Thrift.Type.STRING, 1)
output.writeString(this.start_token)
output.writeFieldEnd()
}
if (null != this.end_token) {
output.writeFieldBegin('end_token', Thrift.Type.STRING, 2)
output.writeString(this.end_token)
output.writeFieldEnd()
}
if (null != this.keys_per_split) {
output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 3)
output.writeI32(this.keys_per_split)
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var Cassandra_describe_splits_result = function(args){
this.success = null
if( args != null ){if (null != args.success)
this.success = args.success
}}
Cassandra_describe_splits_result.prototype = {}
Cassandra_describe_splits_result.prototype.read = function(input){ 
var ret = input.readStructBegin()
while (1) 
{
var ret = input.readFieldBegin()
var fname = ret.fname
var ftype = ret.ftype
var fid   = ret.fid
if (ftype == Thrift.Type.STOP) 
break
switch(fid)
{
case 0:if (ftype == Thrift.Type.LIST) {
{
var _size195 = 0
var rtmp3
this.success = []
var _etype198 = 0
rtmp3 = input.readListBegin()
_etype198 = rtmp3.etype
_size195 = rtmp3.size
for (var _i199 = 0; _i199 < _size195; ++_i199)
{
var elem200 = null
var rtmp = input.readString()
elem200 = rtmp.value
this.success.push(elem200)
}
input.readListEnd()
}
} else {
  input.skip(ftype)
}
break
default:
  input.skip(ftype)
}
input.readFieldEnd()
}
input.readStructEnd()
return
}

Cassandra_describe_splits_result.prototype.write = function(output){ 
output.writeStructBegin('Cassandra_describe_splits_result')
if (null != this.success) {
output.writeFieldBegin('success', Thrift.Type.LIST, 0)
{
output.writeListBegin(Thrift.Type.STRING, this.success.length)
{
for(var iter201 in this.success)
{
iter201=this.success[iter201]
output.writeString(iter201)
}
}
output.writeListEnd()
}
output.writeFieldEnd()
}
output.writeFieldStop()
output.writeStructEnd()
return
}

var CassandraClient = exports.Client = function(output, pClass) {
  this.output = output;
  this.pClass = pClass;
  this.seqid = 0;
  this._reqs = {}
}
CassandraClient.prototype = {}
CassandraClient.prototype.login = function(keyspace,auth_request,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_login(keyspace, auth_request)
}

CassandraClient.prototype.send_login = function(keyspace,auth_request){
var output = new this.pClass(this.output);
output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_login_args()
args.keyspace = keyspace
args.auth_request = auth_request
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_login = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_login_result()
result.read(input)
input.readMessageEnd()

if (null != result.authnx) {
  return callback(result.authnx);
}
if (null != result.authzx) {
  return callback(result.authzx);
}
return
}
CassandraClient.prototype.get = function(keyspace,key,column_path,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get(keyspace, key, column_path, consistency_level)
}

CassandraClient.prototype.send_get = function(keyspace,key,column_path,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_args()
args.keyspace = keyspace
args.key = key
args.column_path = column_path
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.nfe) {
  return callback(result.nfe);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get failed: unknown result");
}
CassandraClient.prototype.get_slice = function(keyspace,key,column_parent,predicate,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_slice(keyspace, key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_slice = function(keyspace,key,column_parent,predicate,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_slice_args()
args.keyspace = keyspace
args.key = key
args.column_parent = column_parent
args.predicate = predicate
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_slice_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_slice failed: unknown result");
}
CassandraClient.prototype.multiget = function(keyspace,keys,column_path,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_multiget(keyspace, keys, column_path, consistency_level)
}

CassandraClient.prototype.send_multiget = function(keyspace,keys,column_path,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('multiget', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_multiget_args()
args.keyspace = keyspace
args.keys = keys
args.column_path = column_path
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_multiget = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_multiget_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("multiget failed: unknown result");
}
CassandraClient.prototype.multiget_slice = function(keyspace,keys,column_parent,predicate,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_multiget_slice(keyspace, keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_slice = function(keyspace,keys,column_parent,predicate,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_multiget_slice_args()
args.keyspace = keyspace
args.keys = keys
args.column_parent = column_parent
args.predicate = predicate
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_multiget_slice_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("multiget_slice failed: unknown result");
}
CassandraClient.prototype.get_count = function(keyspace,key,column_parent,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_count(keyspace, key, column_parent, consistency_level)
}

CassandraClient.prototype.send_get_count = function(keyspace,key,column_parent,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_count_args()
args.keyspace = keyspace
args.key = key
args.column_parent = column_parent
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_count_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_count failed: unknown result");
}
CassandraClient.prototype.get_range_slice = function(keyspace,column_parent,predicate,start_key,finish_key,row_count,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_range_slice(keyspace, column_parent, predicate, start_key, finish_key, row_count, consistency_level)
}

CassandraClient.prototype.send_get_range_slice = function(keyspace,column_parent,predicate,start_key,finish_key,row_count,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_range_slice', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_range_slice_args()
args.keyspace = keyspace
args.column_parent = column_parent
args.predicate = predicate
args.start_key = start_key
args.finish_key = finish_key
args.row_count = row_count
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_range_slice = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_range_slice_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_range_slice failed: unknown result");
}
CassandraClient.prototype.get_range_slices = function(keyspace,column_parent,predicate,range,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_range_slices(keyspace, column_parent, predicate, range, consistency_level)
}

CassandraClient.prototype.send_get_range_slices = function(keyspace,column_parent,predicate,range,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_range_slices_args()
args.keyspace = keyspace
args.column_parent = column_parent
args.predicate = predicate
args.range = range
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_range_slices_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_range_slices failed: unknown result");
}
CassandraClient.prototype.insert = function(keyspace,key,column_path,value,timestamp,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_insert(keyspace, key, column_path, value, timestamp, consistency_level)
}

CassandraClient.prototype.send_insert = function(keyspace,key,column_path,value,timestamp,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_insert_args()
args.keyspace = keyspace
args.key = key
args.column_path = column_path
args.value = value
args.timestamp = timestamp
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_insert_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
return
}
CassandraClient.prototype.batch_insert = function(keyspace,key,cfmap,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_batch_insert(keyspace, key, cfmap, consistency_level)
}

CassandraClient.prototype.send_batch_insert = function(keyspace,key,cfmap,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('batch_insert', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_batch_insert_args()
args.keyspace = keyspace
args.key = key
args.cfmap = cfmap
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_batch_insert = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_batch_insert_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
return
}
CassandraClient.prototype.remove = function(keyspace,key,column_path,timestamp,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_remove(keyspace, key, column_path, timestamp, consistency_level)
}

CassandraClient.prototype.send_remove = function(keyspace,key,column_path,timestamp,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_remove_args()
args.keyspace = keyspace
args.key = key
args.column_path = column_path
args.timestamp = timestamp
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_remove_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
return
}
CassandraClient.prototype.batch_mutate = function(keyspace,mutation_map,consistency_level,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_batch_mutate(keyspace, mutation_map, consistency_level)
}

CassandraClient.prototype.send_batch_mutate = function(keyspace,mutation_map,consistency_level){
var output = new this.pClass(this.output);
output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_batch_mutate_args()
args.keyspace = keyspace
args.mutation_map = mutation_map
args.consistency_level = consistency_level
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_batch_mutate_result()
result.read(input)
input.readMessageEnd()

if (null != result.ire) {
  return callback(result.ire);
}
if (null != result.ue) {
  return callback(result.ue);
}
if (null != result.te) {
  return callback(result.te);
}
return
}
CassandraClient.prototype.get_string_property = function(property,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_string_property(property)
}

CassandraClient.prototype.send_get_string_property = function(property){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_string_property', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_string_property_args()
args.property = property
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_string_property = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_string_property_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_string_property failed: unknown result");
}
CassandraClient.prototype.get_string_list_property = function(property,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_string_list_property(property)
}

CassandraClient.prototype.send_get_string_list_property = function(property){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_string_list_property', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_string_list_property_args()
args.property = property
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_string_list_property = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_string_list_property_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_string_list_property failed: unknown result");
}
CassandraClient.prototype.describe_keyspaces = function(callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_describe_keyspaces()
}

CassandraClient.prototype.send_describe_keyspaces = function(){
var output = new this.pClass(this.output);
output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_describe_keyspaces_args()
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_describe_keyspaces_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("describe_keyspaces failed: unknown result");
}
CassandraClient.prototype.describe_cluster_name = function(callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_describe_cluster_name()
}

CassandraClient.prototype.send_describe_cluster_name = function(){
var output = new this.pClass(this.output);
output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_describe_cluster_name_args()
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_describe_cluster_name_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("describe_cluster_name failed: unknown result");
}
CassandraClient.prototype.describe_version = function(callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_describe_version()
}

CassandraClient.prototype.send_describe_version = function(){
var output = new this.pClass(this.output);
output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_describe_version_args()
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_describe_version_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("describe_version failed: unknown result");
}
CassandraClient.prototype.describe_ring = function(keyspace,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_describe_ring(keyspace)
}

CassandraClient.prototype.send_describe_ring = function(keyspace){
var output = new this.pClass(this.output);
output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_describe_ring_args()
args.keyspace = keyspace
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_describe_ring_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("describe_ring failed: unknown result");
}
CassandraClient.prototype.describe_keyspace = function(keyspace,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_describe_keyspace(keyspace)
}

CassandraClient.prototype.send_describe_keyspace = function(keyspace){
var output = new this.pClass(this.output);
output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_describe_keyspace_args()
args.keyspace = keyspace
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_describe_keyspace_result()
result.read(input)
input.readMessageEnd()

if (null != result.nfe) {
  return callback(result.nfe);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("describe_keyspace failed: unknown result");
}
CassandraClient.prototype.take_snapshot = function(table_name,snapshot_name,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_take_snapshot(table_name, snapshot_name)
}

CassandraClient.prototype.send_take_snapshot = function(table_name,snapshot_name){
var output = new this.pClass(this.output);
output.writeMessageBegin('take_snapshot', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_take_snapshot_args()
args.table_name = table_name
args.snapshot_name = snapshot_name
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_take_snapshot = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_take_snapshot_result()
result.read(input)
input.readMessageEnd()

return
}
CassandraClient.prototype.force_table_clean = function(callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_force_table_clean()
}

CassandraClient.prototype.send_force_table_clean = function(){
var output = new this.pClass(this.output);
output.writeMessageBegin('force_table_clean', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_force_table_clean_args()
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_force_table_clean = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_force_table_clean_result()
result.read(input)
input.readMessageEnd()

return
}
CassandraClient.prototype.force_table_compaction = function(callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_force_table_compaction()
}

CassandraClient.prototype.send_force_table_compaction = function(){
var output = new this.pClass(this.output);
output.writeMessageBegin('force_table_compaction', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_force_table_compaction_args()
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_force_table_compaction = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_force_table_compaction_result()
result.read(input)
input.readMessageEnd()

return
}
CassandraClient.prototype.force_table_flush = function(table_name,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_force_table_flush(table_name)
}

CassandraClient.prototype.send_force_table_flush = function(table_name){
var output = new this.pClass(this.output);
output.writeMessageBegin('force_table_flush', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_force_table_flush_args()
args.table_name = table_name
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_force_table_flush = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_force_table_flush_result()
result.read(input)
input.readMessageEnd()

return
}
CassandraClient.prototype.get_table_stats = function(table_name,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_get_table_stats(table_name)
}

CassandraClient.prototype.send_get_table_stats = function(table_name){
var output = new this.pClass(this.output);
output.writeMessageBegin('get_table_stats', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_get_table_stats_args()
args.table_name = table_name
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_get_table_stats = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_get_table_stats_result()
result.read(input)
input.readMessageEnd()

if (null != result.nfe) {
  return callback(result.nfe);
}
if (null != result.success ) {
  return callback(null, result.success);
}
return callback("get_table_stats failed: unknown result");
}
CassandraClient.prototype.describe_splits = function(start_token,end_token,keys_per_split,callback){
this.seqid += 1;
this._reqs[this.seqid] = callback;
this.send_describe_splits(start_token, end_token, keys_per_split)
}

CassandraClient.prototype.send_describe_splits = function(start_token,end_token,keys_per_split){
var output = new this.pClass(this.output);
output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid)
var args = new Cassandra_describe_splits_args()
args.start_token = start_token
args.end_token = end_token
args.keys_per_split = keys_per_split
args.write(output)
output.writeMessageEnd()
return this.output.flush()
}

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid){
var callback = this._reqs[rseqid] || function() {};
delete this._reqs[rseqid];
if (mtype == Thrift.MessageType.EXCEPTION) {
  var x = new Thrift.ApplicationException()
  x.read(input)
  input.readMessageEnd()
  return callback(x);
}
var result = new Cassandra_describe_splits_result()
result.read(input)
input.readMessageEnd()

if (null != result.success ) {
  return callback(null, result.success);
}
return callback("describe_splits failed: unknown result");
}
